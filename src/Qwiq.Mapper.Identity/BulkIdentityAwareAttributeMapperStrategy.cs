using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;

using FastMember;
using JetBrains.Annotations;
using Microsoft.Qwiq.Identity;
using Microsoft.Qwiq.Mapper.Attributes;

namespace Microsoft.Qwiq.Mapper
{
    /// <summary>
    /// Class BulkIdentityAwareAttributeMapperStrategy.
    /// </summary>
    /// <seealso cref="WorkItemMapperStrategyBase" />
    public class BulkIdentityAwareAttributeMapperStrategy : WorkItemMapperStrategyBase
    {
        private readonly IPropertyInspector _inspector;
        private readonly IIdentityValueConverter<string, object> _displayNameToAliasValueConverter;
        private static readonly Hashtable IdentityPropertyTypeMap = new Hashtable();

        /// <summary>
        /// Initializes a new instance of the <see cref="BulkIdentityAwareAttributeMapperStrategy" /> class.
        /// </summary>
        /// <param name="inspector">The inspector.</param>
        /// <param name="identityManagementService">The identity management service.</param>
        /// <exception cref="ArgumentNullException">
        /// inspector
        /// or
        /// identityManagementService
        /// </exception>
        public BulkIdentityAwareAttributeMapperStrategy(IPropertyInspector inspector, IIdentityManagementService identityManagementService)
            : this(inspector, new IdentityFieldValueConverter(identityManagementService))
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BulkIdentityAwareAttributeMapperStrategy"/> class.
        /// </summary>
        /// <param name="inspector">The inspector.</param>
        /// <param name="identityValueConverter">The identity value converter.</param>
        /// <exception cref="ArgumentNullException">inspector</exception>
        /// <autogeneratedoc />
        public BulkIdentityAwareAttributeMapperStrategy(
            IPropertyInspector inspector,
            IIdentityValueConverter<string, object> identityValueConverter
            )
        {
            Contract.Requires(inspector != null);
            Contract.Requires(identityValueConverter != null);

            _inspector = inspector ?? throw new ArgumentNullException(nameof(inspector));
            _displayNameToAliasValueConverter = identityValueConverter ?? throw new ArgumentNullException(nameof(identityValueConverter));
        }

        /// <summary>
        /// Maps the specified target work item type.
        /// </summary>
        /// <param name="targeWorkItemType">Type of the targe work item.</param>
        /// <param name="workItemMappings">The work item mappings.</param>
        /// <param name="workItemMapper">The work item mapper.</param>
        public override void Map(Type targeWorkItemType, IDictionary<IWorkItem, IIdentifiable<int?>> workItemMappings, IWorkItemMapper workItemMapper)
        {
            if (!workItemMappings.Any()) return;

            var validIdentityProperties = GetWorkItemIdentityFieldNameToIdentityPropertyMap(targeWorkItemType, _inspector);
            if (!validIdentityProperties.Any()) return;

            var validIdentityFieldsWithWorkItems = GetWorkItemsWithIdentityFieldValues(workItemMappings.Keys, validIdentityProperties.Keys);
            var identitySearchTerms = GetIdentitySearchTerms(validIdentityFieldsWithWorkItems);
            var identitySearchResults = MapIdentityValues(identitySearchTerms);

            foreach (var workItem in validIdentityFieldsWithWorkItems)
            {
                var targetObject = workItemMappings[workItem.WorkItem];
                foreach (var sourceField in workItem.ValidFields)
                {
                    var targetProperties = validIdentityProperties[sourceField.Name];
                    var mappedValue = identitySearchResults[sourceField.Value];

                    foreach (var targetProperty in targetProperties)
                    {
                        AssignFieldValue(targeWorkItemType, workItem.WorkItem, targetObject, targetProperty,
                            sourceField.Name, true, sourceField.Value, mappedValue);
                    }
                }
            }
        }

        protected internal virtual void AssignFieldValue(
            [NotNull] Type targetWorkItemType,
            [NotNull] IWorkItem sourceWorkItem,
            [NotNull] object targetWorkItem,
            [NotNull] PropertyInfo property,
            [NotNull] string fieldName,
            bool convert,
            [CanBeNull] object nullSub,
            [CanBeNull] object fieldValue)
        {
            // Coalesce fieldValue and nullSub

            if (fieldValue == null && nullSub != null)
            {
                fieldValue = nullSub;
            }
            else
            {
                if (fieldValue is string value && string.IsNullOrWhiteSpace(value))
                    fieldValue = nullSub;
            }

            var destType = property.PropertyType;

            if (fieldValue == null && destType.IsValueType)
            {
                // Value types do not accept null; don't do any work
                return;
            }

            if (fieldValue == null && destType.CanAcceptNull())
            {
                // Destination is a nullable or can take null; don't do any work
                return;
            }

            if (convert)
            {
                try
                {
                    fieldValue = TypeParser.Default.Parse(destType, fieldValue);
                }
                catch (Exception e)
                {
                    var tm = new TypePair(sourceWorkItem, targetWorkItemType);
                    var pm = new PropertyMap(property, fieldName);
                    var message = $"Unable to convert identity field value on {sourceWorkItem.Id}.";
                    throw new AttributeMapException(message, e, tm, pm);
                }
            }

            var accessor = TypeAccessor.Create(targetWorkItemType, true);

            try
            {
                accessor[targetWorkItem, property.Name] = fieldValue;
            }
            catch (Exception e)
            {
                var tm = new TypePair(sourceWorkItem, targetWorkItemType);
                var pm = new PropertyMap(property, fieldName);
                var message = $"Unable to set identity field value on {sourceWorkItem.Id}.";
                throw new AttributeMapException(message, e, tm, pm);
            }
        }

        private IReadOnlyDictionary<string, object> MapIdentityValues(IEnumerable<string> identitySearchTerms)
        {
            try
            {
                return _displayNameToAliasValueConverter.Map(identitySearchTerms);
            }
            catch (Exception e)
            {
                throw new AttributeMapException("Unable to map identity values.", e);
            }
        }


        private static List<WorkItemWithFields> GetWorkItemsWithIdentityFieldValues(
            IEnumerable<IWorkItem> workItems,
            Dictionary<string, List<PropertyInfo>>.KeyCollection witFieldNames)
        {
            var retval = new List<WorkItemWithFields>();
            foreach (var wi in workItems)
            {
                var vf = new List<WorkItemField>(witFieldNames.Count);
                foreach (var fn in witFieldNames)
                {
                    if (!wi.Fields.Contains(fn)) continue;
                    var fv = wi[fn] as string;

                    if (string.IsNullOrEmpty(fv)) continue;
                    vf.Add(new WorkItemField { Name = fn, Value = fv });
                }

                retval.Add(new WorkItemWithFields
                {
                    WorkItem = wi,
                    ValidFields = vf
                });
            }
            return retval;
        }

        internal static HashSet<string> GetIdentitySearchTerms(List<WorkItemWithFields> workItemsWithIdentityFields)
        {
            var set = new HashSet<string>();
            foreach (var wiwf in workItemsWithIdentityFields)
            {
                foreach (var f in wiwf.ValidFields)
                {
                    set.Add(f.Value);
                }
            }

            return set;
        }

        internal static Dictionary<string, List<PropertyInfo>> GetWorkItemIdentityFieldNameToIdentityPropertyMap(Type targetWorkItemType, IPropertyInspector propertyInspector)
        {
            var hashtable = IdentityPropertyTypeMap;
            var props = (Dictionary<string, List<PropertyInfo>>)hashtable[targetWorkItemType];

            if (props != null) return props;

            lock (hashtable)
            {

                var identityProperties =
                    propertyInspector.GetAnnotatedProperties(targetWorkItemType, typeof(IdentityFieldAttribute));
                props = new Dictionary<string, List<PropertyInfo>>(StringComparer.OrdinalIgnoreCase);
                foreach (var identityProperty in identityProperties)
                {
                    var witFieldName = propertyInspector.GetAttribute<FieldDefinitionAttribute>(identityProperty)
                        ?.FieldName;
                    if (string.IsNullOrEmpty(witFieldName) || !identityProperty.CanWrite) continue;

                    if (!props.ContainsKey(witFieldName)) props.Add(witFieldName, new List<PropertyInfo>());
                    props[witFieldName].Add(identityProperty);
                }

                hashtable[targetWorkItemType] = props;
                return props;
            }
        }
    }
}

